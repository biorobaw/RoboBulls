// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages_robocup_ssl_detection_tracked.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "libs/ssl-vision/include/messages/messages_robocup_ssl_detection_tracked.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* Vector2_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vector2_reflection_ = NULL;
const ::google::protobuf::Descriptor* Vector3_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vector3_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotId_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotId_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrackedBall_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrackedBall_reflection_ = NULL;
const ::google::protobuf::Descriptor* KickedBall_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KickedBall_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrackedRobot_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrackedRobot_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrackedFrame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrackedFrame_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TeamColor_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Capability_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto() {
  protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages_robocup_ssl_detection_tracked.proto");
  GOOGLE_CHECK(file != NULL);
  Vector2_descriptor_ = file->message_type(0);
  static const int Vector2_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector2, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector2, y_),
  };
  Vector2_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Vector2_descriptor_,
      Vector2::default_instance_,
      Vector2_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector2, _has_bits_[0]),
      -1,
      -1,
      sizeof(Vector2),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector2, _internal_metadata_),
      -1);
  Vector3_descriptor_ = file->message_type(1);
  static const int Vector3_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector3, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector3, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector3, z_),
  };
  Vector3_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Vector3_descriptor_,
      Vector3::default_instance_,
      Vector3_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector3, _has_bits_[0]),
      -1,
      -1,
      sizeof(Vector3),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector3, _internal_metadata_),
      -1);
  RobotId_descriptor_ = file->message_type(2);
  static const int RobotId_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotId, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotId, team_color_),
  };
  RobotId_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RobotId_descriptor_,
      RobotId::default_instance_,
      RobotId_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotId, _has_bits_[0]),
      -1,
      -1,
      sizeof(RobotId),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotId, _internal_metadata_),
      -1);
  TrackedBall_descriptor_ = file->message_type(3);
  static const int TrackedBall_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBall, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBall, vel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBall, visibility_),
  };
  TrackedBall_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrackedBall_descriptor_,
      TrackedBall::default_instance_,
      TrackedBall_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBall, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrackedBall),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedBall, _internal_metadata_),
      -1);
  KickedBall_descriptor_ = file->message_type(4);
  static const int KickedBall_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KickedBall, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KickedBall, vel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KickedBall, start_timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KickedBall, stop_timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KickedBall, stop_pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KickedBall, robot_id_),
  };
  KickedBall_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      KickedBall_descriptor_,
      KickedBall::default_instance_,
      KickedBall_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KickedBall, _has_bits_[0]),
      -1,
      -1,
      sizeof(KickedBall),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KickedBall, _internal_metadata_),
      -1);
  TrackedRobot_descriptor_ = file->message_type(5);
  static const int TrackedRobot_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedRobot, robot_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedRobot, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedRobot, orientation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedRobot, vel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedRobot, vel_angular_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedRobot, visibility_),
  };
  TrackedRobot_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrackedRobot_descriptor_,
      TrackedRobot::default_instance_,
      TrackedRobot_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedRobot, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrackedRobot),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedRobot, _internal_metadata_),
      -1);
  TrackedFrame_descriptor_ = file->message_type(6);
  static const int TrackedFrame_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedFrame, frame_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedFrame, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedFrame, balls_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedFrame, robots_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedFrame, kicked_ball_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedFrame, capabilities_),
  };
  TrackedFrame_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrackedFrame_descriptor_,
      TrackedFrame::default_instance_,
      TrackedFrame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedFrame, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrackedFrame),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackedFrame, _internal_metadata_),
      -1);
  TeamColor_descriptor_ = file->enum_type(0);
  Capability_descriptor_ = file->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Vector2_descriptor_, &Vector2::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Vector3_descriptor_, &Vector3::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RobotId_descriptor_, &RobotId::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrackedBall_descriptor_, &TrackedBall::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      KickedBall_descriptor_, &KickedBall::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrackedRobot_descriptor_, &TrackedRobot::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrackedFrame_descriptor_, &TrackedFrame::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto() {
  delete Vector2::default_instance_;
  delete Vector2_reflection_;
  delete Vector3::default_instance_;
  delete Vector3_reflection_;
  delete RobotId::default_instance_;
  delete RobotId_reflection_;
  delete TrackedBall::default_instance_;
  delete TrackedBall_reflection_;
  delete KickedBall::default_instance_;
  delete KickedBall_reflection_;
  delete TrackedRobot::default_instance_;
  delete TrackedRobot_reflection_;
  delete TrackedFrame::default_instance_;
  delete TrackedFrame_reflection_;
}

void protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n,messages_robocup_ssl_detection_tracked"
    ".proto\"\037\n\007Vector2\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\""
    "*\n\007Vector3\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 "
    "\002(\002\"5\n\007RobotId\022\n\n\002id\030\001 \002(\r\022\036\n\nteam_color"
    "\030\002 \002(\0162\n.TeamColor\"O\n\013TrackedBall\022\025\n\003pos"
    "\030\001 \002(\0132\010.Vector3\022\025\n\003vel\030\002 \001(\0132\010.Vector3\022"
    "\022\n\nvisibility\030\003 \001(\002\"\243\001\n\nKickedBall\022\025\n\003po"
    "s\030\001 \002(\0132\010.Vector2\022\025\n\003vel\030\002 \002(\0132\010.Vector3"
    "\022\027\n\017start_timestamp\030\003 \002(\001\022\026\n\016stop_timest"
    "amp\030\004 \001(\001\022\032\n\010stop_pos\030\005 \001(\0132\010.Vector2\022\032\n"
    "\010robot_id\030\006 \001(\0132\010.RobotId\"\226\001\n\014TrackedRob"
    "ot\022\032\n\010robot_id\030\001 \002(\0132\010.RobotId\022\025\n\003pos\030\002 "
    "\002(\0132\010.Vector2\022\023\n\013orientation\030\003 \002(\002\022\025\n\003ve"
    "l\030\004 \001(\0132\010.Vector2\022\023\n\013vel_angular\030\005 \001(\002\022\022"
    "\n\nvisibility\030\006 \001(\002\"\270\001\n\014TrackedFrame\022\024\n\014f"
    "rame_number\030\001 \002(\r\022\021\n\ttimestamp\030\002 \002(\001\022\033\n\005"
    "balls\030\003 \003(\0132\014.TrackedBall\022\035\n\006robots\030\004 \003("
    "\0132\r.TrackedRobot\022 \n\013kicked_ball\030\005 \001(\0132\013."
    "KickedBall\022!\n\014capabilities\030\006 \003(\0162\013.Capab"
    "ility*O\n\tTeamColor\022\026\n\022TEAM_COLOR_UNKNOWN"
    "\020\000\022\025\n\021TEAM_COLOR_YELLOW\020\001\022\023\n\017TEAM_COLOR_"
    "BLUE\020\002*\222\001\n\nCapability\022\026\n\022CAPABILITY_UNKN"
    "OWN\020\000\022\"\n\036CAPABILITY_DETECT_FLYING_BALLS\020"
    "\001\022$\n CAPABILITY_DETECT_MULTIPLE_BALLS\020\002\022"
    "\"\n\036CAPABILITY_DETECT_KICKED_BALLS\020\003", 995);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages_robocup_ssl_detection_tracked.proto", &protobuf_RegisterTypes);
  Vector2::default_instance_ = new Vector2();
  Vector3::default_instance_ = new Vector3();
  RobotId::default_instance_ = new RobotId();
  TrackedBall::default_instance_ = new TrackedBall();
  KickedBall::default_instance_ = new KickedBall();
  TrackedRobot::default_instance_ = new TrackedRobot();
  TrackedFrame::default_instance_ = new TrackedFrame();
  Vector2::default_instance_->InitAsDefaultInstance();
  Vector3::default_instance_->InitAsDefaultInstance();
  RobotId::default_instance_->InitAsDefaultInstance();
  TrackedBall::default_instance_->InitAsDefaultInstance();
  KickedBall::default_instance_->InitAsDefaultInstance();
  TrackedRobot::default_instance_->InitAsDefaultInstance();
  TrackedFrame::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto {
  StaticDescriptorInitializer_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto() {
    protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto();
  }
} static_descriptor_initializer_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto_;
const ::google::protobuf::EnumDescriptor* TeamColor_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TeamColor_descriptor_;
}
bool TeamColor_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Capability_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Capability_descriptor_;
}
bool Capability_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Vector2::kXFieldNumber;
const int Vector2::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Vector2::Vector2()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Vector2)
}

void Vector2::InitAsDefaultInstance() {
}

Vector2::Vector2(const Vector2& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Vector2)
}

void Vector2::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vector2::~Vector2() {
  // @@protoc_insertion_point(destructor:Vector2)
  SharedDtor();
}

void Vector2::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vector2::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vector2::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vector2_descriptor_;
}

const Vector2& Vector2::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto();
  return *default_instance_;
}

Vector2* Vector2::default_instance_ = NULL;

Vector2* Vector2::New(::google::protobuf::Arena* arena) const {
  Vector2* n = new Vector2;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Vector2::Clear() {
// @@protoc_insertion_point(message_clear_start:Vector2)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Vector2, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Vector2*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, y_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Vector2::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Vector2)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Vector2)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Vector2)
  return false;
#undef DO_
}

void Vector2::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Vector2)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Vector2)
}

::google::protobuf::uint8* Vector2::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Vector2)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Vector2)
  return target;
}

int Vector2::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Vector2)
  int total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
int Vector2::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Vector2)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vector2::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Vector2)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Vector2* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Vector2>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Vector2)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Vector2)
    MergeFrom(*source);
  }
}

void Vector2::MergeFrom(const Vector2& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Vector2)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Vector2::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Vector2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vector2::CopyFrom(const Vector2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Vector2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector2::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Vector2::Swap(Vector2* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Vector2::InternalSwap(Vector2* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Vector2::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vector2_descriptor_;
  metadata.reflection = Vector2_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Vector2

// required float x = 1;
bool Vector2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Vector2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Vector2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Vector2::clear_x() {
  x_ = 0;
  clear_has_x();
}
 float Vector2::x() const {
  // @@protoc_insertion_point(field_get:Vector2.x)
  return x_;
}
 void Vector2::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector2.x)
}

// required float y = 2;
bool Vector2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Vector2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Vector2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Vector2::clear_y() {
  y_ = 0;
  clear_has_y();
}
 float Vector2::y() const {
  // @@protoc_insertion_point(field_get:Vector2.y)
  return y_;
}
 void Vector2::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector2.y)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Vector3::kXFieldNumber;
const int Vector3::kYFieldNumber;
const int Vector3::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Vector3::Vector3()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Vector3)
}

void Vector3::InitAsDefaultInstance() {
}

Vector3::Vector3(const Vector3& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Vector3)
}

void Vector3::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vector3::~Vector3() {
  // @@protoc_insertion_point(destructor:Vector3)
  SharedDtor();
}

void Vector3::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vector3::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vector3::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vector3_descriptor_;
}

const Vector3& Vector3::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto();
  return *default_instance_;
}

Vector3* Vector3::default_instance_ = NULL;

Vector3* Vector3::New(::google::protobuf::Arena* arena) const {
  Vector3* n = new Vector3;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Vector3::Clear() {
// @@protoc_insertion_point(message_clear_start:Vector3)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Vector3, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Vector3*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, z_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Vector3::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Vector3)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (tag == 29) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Vector3)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Vector3)
  return false;
#undef DO_
}

void Vector3::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Vector3)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Vector3)
}

::google::protobuf::uint8* Vector3::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Vector3)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Vector3)
  return target;
}

int Vector3::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Vector3)
  int total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  if (has_z()) {
    // required float z = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
int Vector3::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Vector3)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

    // required float z = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vector3::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Vector3)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Vector3* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Vector3>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Vector3)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Vector3)
    MergeFrom(*source);
  }
}

void Vector3::MergeFrom(const Vector3& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Vector3)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Vector3::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Vector3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vector3::CopyFrom(const Vector3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Vector3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector3::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Vector3::Swap(Vector3* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Vector3::InternalSwap(Vector3* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Vector3::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vector3_descriptor_;
  metadata.reflection = Vector3_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Vector3

// required float x = 1;
bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
 float Vector3::x() const {
  // @@protoc_insertion_point(field_get:Vector3.x)
  return x_;
}
 void Vector3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector3.x)
}

// required float y = 2;
bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
 float Vector3::y() const {
  // @@protoc_insertion_point(field_get:Vector3.y)
  return y_;
}
 void Vector3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector3.y)
}

// required float z = 3;
bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
 float Vector3::z() const {
  // @@protoc_insertion_point(field_get:Vector3.z)
  return z_;
}
 void Vector3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Vector3.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RobotId::kIdFieldNumber;
const int RobotId::kTeamColorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RobotId::RobotId()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RobotId)
}

void RobotId::InitAsDefaultInstance() {
}

RobotId::RobotId(const RobotId& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RobotId)
}

void RobotId::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  team_color_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotId::~RobotId() {
  // @@protoc_insertion_point(destructor:RobotId)
  SharedDtor();
}

void RobotId::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobotId::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotId::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotId_descriptor_;
}

const RobotId& RobotId::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto();
  return *default_instance_;
}

RobotId* RobotId::default_instance_ = NULL;

RobotId* RobotId::New(::google::protobuf::Arena* arena) const {
  RobotId* n = new RobotId;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RobotId::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotId)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RobotId, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RobotId*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(id_, team_color_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RobotId::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RobotId)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_team_color;
        break;
      }

      // required .TeamColor team_color = 2;
      case 2: {
        if (tag == 16) {
         parse_team_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TeamColor_IsValid(value)) {
            set_team_color(static_cast< ::TeamColor >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RobotId)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RobotId)
  return false;
#undef DO_
}

void RobotId::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RobotId)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required .TeamColor team_color = 2;
  if (has_team_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->team_color(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RobotId)
}

::google::protobuf::uint8* RobotId::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotId)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required .TeamColor team_color = 2;
  if (has_team_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->team_color(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotId)
  return target;
}

int RobotId::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RobotId)
  int total_size = 0;

  if (has_id()) {
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }

  if (has_team_color()) {
    // required .TeamColor team_color = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->team_color());
  }

  return total_size;
}
int RobotId::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RobotId)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());

    // required .TeamColor team_color = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->team_color());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotId::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RobotId)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RobotId* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RobotId>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RobotId)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RobotId)
    MergeFrom(*source);
  }
}

void RobotId::MergeFrom(const RobotId& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotId)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_team_color()) {
      set_team_color(from.team_color());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RobotId::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RobotId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotId::CopyFrom(const RobotId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotId::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RobotId::Swap(RobotId* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RobotId::InternalSwap(RobotId* other) {
  std::swap(id_, other->id_);
  std::swap(team_color_, other->team_color_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RobotId::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotId_descriptor_;
  metadata.reflection = RobotId_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RobotId

// required uint32 id = 1;
bool RobotId::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RobotId::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void RobotId::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void RobotId::clear_id() {
  id_ = 0u;
  clear_has_id();
}
 ::google::protobuf::uint32 RobotId::id() const {
  // @@protoc_insertion_point(field_get:RobotId.id)
  return id_;
}
 void RobotId::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:RobotId.id)
}

// required .TeamColor team_color = 2;
bool RobotId::has_team_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RobotId::set_has_team_color() {
  _has_bits_[0] |= 0x00000002u;
}
void RobotId::clear_has_team_color() {
  _has_bits_[0] &= ~0x00000002u;
}
void RobotId::clear_team_color() {
  team_color_ = 0;
  clear_has_team_color();
}
 ::TeamColor RobotId::team_color() const {
  // @@protoc_insertion_point(field_get:RobotId.team_color)
  return static_cast< ::TeamColor >(team_color_);
}
 void RobotId::set_team_color(::TeamColor value) {
  assert(::TeamColor_IsValid(value));
  set_has_team_color();
  team_color_ = value;
  // @@protoc_insertion_point(field_set:RobotId.team_color)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrackedBall::kPosFieldNumber;
const int TrackedBall::kVelFieldNumber;
const int TrackedBall::kVisibilityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrackedBall::TrackedBall()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrackedBall)
}

void TrackedBall::InitAsDefaultInstance() {
  pos_ = const_cast< ::Vector3*>(&::Vector3::default_instance());
  vel_ = const_cast< ::Vector3*>(&::Vector3::default_instance());
}

TrackedBall::TrackedBall(const TrackedBall& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TrackedBall)
}

void TrackedBall::SharedCtor() {
  _cached_size_ = 0;
  pos_ = NULL;
  vel_ = NULL;
  visibility_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrackedBall::~TrackedBall() {
  // @@protoc_insertion_point(destructor:TrackedBall)
  SharedDtor();
}

void TrackedBall::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
    delete vel_;
  }
}

void TrackedBall::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrackedBall::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrackedBall_descriptor_;
}

const TrackedBall& TrackedBall::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto();
  return *default_instance_;
}

TrackedBall* TrackedBall::default_instance_ = NULL;

TrackedBall* TrackedBall::New(::google::protobuf::Arena* arena) const {
  TrackedBall* n = new TrackedBall;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrackedBall::Clear() {
// @@protoc_insertion_point(message_clear_start:TrackedBall)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_pos()) {
      if (pos_ != NULL) pos_->::Vector3::Clear();
    }
    if (has_vel()) {
      if (vel_ != NULL) vel_->::Vector3::Clear();
    }
    visibility_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrackedBall::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrackedBall)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Vector3 pos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vel;
        break;
      }

      // optional .Vector3 vel = 2;
      case 2: {
        if (tag == 18) {
         parse_vel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_visibility;
        break;
      }

      // optional float visibility = 3;
      case 3: {
        if (tag == 29) {
         parse_visibility:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &visibility_)));
          set_has_visibility();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrackedBall)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrackedBall)
  return false;
#undef DO_
}

void TrackedBall::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrackedBall)
  // required .Vector3 pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->pos_, output);
  }

  // optional .Vector3 vel = 2;
  if (has_vel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->vel_, output);
  }

  // optional float visibility = 3;
  if (has_visibility()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->visibility(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrackedBall)
}

::google::protobuf::uint8* TrackedBall::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrackedBall)
  // required .Vector3 pos = 1;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->pos_, false, target);
  }

  // optional .Vector3 vel = 2;
  if (has_vel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->vel_, false, target);
  }

  // optional float visibility = 3;
  if (has_visibility()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->visibility(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrackedBall)
  return target;
}

int TrackedBall::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:TrackedBall)
  int total_size = 0;

  // required .Vector3 pos = 1;
  if (has_pos()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pos_);
  }
  if (_has_bits_[1 / 32] & 6u) {
    // optional .Vector3 vel = 2;
    if (has_vel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->vel_);
    }

    // optional float visibility = 3;
    if (has_visibility()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrackedBall::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrackedBall)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TrackedBall* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrackedBall>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrackedBall)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrackedBall)
    MergeFrom(*source);
  }
}

void TrackedBall::MergeFrom(const TrackedBall& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrackedBall)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      mutable_pos()->::Vector3::MergeFrom(from.pos());
    }
    if (from.has_vel()) {
      mutable_vel()->::Vector3::MergeFrom(from.vel());
    }
    if (from.has_visibility()) {
      set_visibility(from.visibility());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrackedBall::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrackedBall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrackedBall::CopyFrom(const TrackedBall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrackedBall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackedBall::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_pos()) {
    if (!this->pos_->IsInitialized()) return false;
  }
  if (has_vel()) {
    if (!this->vel_->IsInitialized()) return false;
  }
  return true;
}

void TrackedBall::Swap(TrackedBall* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrackedBall::InternalSwap(TrackedBall* other) {
  std::swap(pos_, other->pos_);
  std::swap(vel_, other->vel_);
  std::swap(visibility_, other->visibility_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrackedBall::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrackedBall_descriptor_;
  metadata.reflection = TrackedBall_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrackedBall

// required .Vector3 pos = 1;
bool TrackedBall::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrackedBall::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
void TrackedBall::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrackedBall::clear_pos() {
  if (pos_ != NULL) pos_->::Vector3::Clear();
  clear_has_pos();
}
const ::Vector3& TrackedBall::pos() const {
  // @@protoc_insertion_point(field_get:TrackedBall.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
::Vector3* TrackedBall::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:TrackedBall.pos)
  return pos_;
}
::Vector3* TrackedBall::release_pos() {
  // @@protoc_insertion_point(field_release:TrackedBall.pos)
  clear_has_pos();
  ::Vector3* temp = pos_;
  pos_ = NULL;
  return temp;
}
void TrackedBall::set_allocated_pos(::Vector3* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:TrackedBall.pos)
}

// optional .Vector3 vel = 2;
bool TrackedBall::has_vel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrackedBall::set_has_vel() {
  _has_bits_[0] |= 0x00000002u;
}
void TrackedBall::clear_has_vel() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrackedBall::clear_vel() {
  if (vel_ != NULL) vel_->::Vector3::Clear();
  clear_has_vel();
}
const ::Vector3& TrackedBall::vel() const {
  // @@protoc_insertion_point(field_get:TrackedBall.vel)
  return vel_ != NULL ? *vel_ : *default_instance_->vel_;
}
::Vector3* TrackedBall::mutable_vel() {
  set_has_vel();
  if (vel_ == NULL) {
    vel_ = new ::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:TrackedBall.vel)
  return vel_;
}
::Vector3* TrackedBall::release_vel() {
  // @@protoc_insertion_point(field_release:TrackedBall.vel)
  clear_has_vel();
  ::Vector3* temp = vel_;
  vel_ = NULL;
  return temp;
}
void TrackedBall::set_allocated_vel(::Vector3* vel) {
  delete vel_;
  vel_ = vel;
  if (vel) {
    set_has_vel();
  } else {
    clear_has_vel();
  }
  // @@protoc_insertion_point(field_set_allocated:TrackedBall.vel)
}

// optional float visibility = 3;
bool TrackedBall::has_visibility() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TrackedBall::set_has_visibility() {
  _has_bits_[0] |= 0x00000004u;
}
void TrackedBall::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000004u;
}
void TrackedBall::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
 float TrackedBall::visibility() const {
  // @@protoc_insertion_point(field_get:TrackedBall.visibility)
  return visibility_;
}
 void TrackedBall::set_visibility(float value) {
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:TrackedBall.visibility)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int KickedBall::kPosFieldNumber;
const int KickedBall::kVelFieldNumber;
const int KickedBall::kStartTimestampFieldNumber;
const int KickedBall::kStopTimestampFieldNumber;
const int KickedBall::kStopPosFieldNumber;
const int KickedBall::kRobotIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

KickedBall::KickedBall()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:KickedBall)
}

void KickedBall::InitAsDefaultInstance() {
  pos_ = const_cast< ::Vector2*>(&::Vector2::default_instance());
  vel_ = const_cast< ::Vector3*>(&::Vector3::default_instance());
  stop_pos_ = const_cast< ::Vector2*>(&::Vector2::default_instance());
  robot_id_ = const_cast< ::RobotId*>(&::RobotId::default_instance());
}

KickedBall::KickedBall(const KickedBall& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:KickedBall)
}

void KickedBall::SharedCtor() {
  _cached_size_ = 0;
  pos_ = NULL;
  vel_ = NULL;
  start_timestamp_ = 0;
  stop_timestamp_ = 0;
  stop_pos_ = NULL;
  robot_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KickedBall::~KickedBall() {
  // @@protoc_insertion_point(destructor:KickedBall)
  SharedDtor();
}

void KickedBall::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
    delete vel_;
    delete stop_pos_;
    delete robot_id_;
  }
}

void KickedBall::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KickedBall::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KickedBall_descriptor_;
}

const KickedBall& KickedBall::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto();
  return *default_instance_;
}

KickedBall* KickedBall::default_instance_ = NULL;

KickedBall* KickedBall::New(::google::protobuf::Arena* arena) const {
  KickedBall* n = new KickedBall;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void KickedBall::Clear() {
// @@protoc_insertion_point(message_clear_start:KickedBall)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(KickedBall, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<KickedBall*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(start_timestamp_, stop_timestamp_);
    if (has_pos()) {
      if (pos_ != NULL) pos_->::Vector2::Clear();
    }
    if (has_vel()) {
      if (vel_ != NULL) vel_->::Vector3::Clear();
    }
    if (has_stop_pos()) {
      if (stop_pos_ != NULL) stop_pos_->::Vector2::Clear();
    }
    if (has_robot_id()) {
      if (robot_id_ != NULL) robot_id_->::RobotId::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool KickedBall::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:KickedBall)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Vector2 pos = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vel;
        break;
      }

      // required .Vector3 vel = 2;
      case 2: {
        if (tag == 18) {
         parse_vel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_start_timestamp;
        break;
      }

      // required double start_timestamp = 3;
      case 3: {
        if (tag == 25) {
         parse_start_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_timestamp_)));
          set_has_start_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_stop_timestamp;
        break;
      }

      // optional double stop_timestamp = 4;
      case 4: {
        if (tag == 33) {
         parse_stop_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &stop_timestamp_)));
          set_has_stop_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_stop_pos;
        break;
      }

      // optional .Vector2 stop_pos = 5;
      case 5: {
        if (tag == 42) {
         parse_stop_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stop_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_robot_id;
        break;
      }

      // optional .RobotId robot_id = 6;
      case 6: {
        if (tag == 50) {
         parse_robot_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:KickedBall)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:KickedBall)
  return false;
#undef DO_
}

void KickedBall::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:KickedBall)
  // required .Vector2 pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->pos_, output);
  }

  // required .Vector3 vel = 2;
  if (has_vel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->vel_, output);
  }

  // required double start_timestamp = 3;
  if (has_start_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->start_timestamp(), output);
  }

  // optional double stop_timestamp = 4;
  if (has_stop_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->stop_timestamp(), output);
  }

  // optional .Vector2 stop_pos = 5;
  if (has_stop_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->stop_pos_, output);
  }

  // optional .RobotId robot_id = 6;
  if (has_robot_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->robot_id_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:KickedBall)
}

::google::protobuf::uint8* KickedBall::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:KickedBall)
  // required .Vector2 pos = 1;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->pos_, false, target);
  }

  // required .Vector3 vel = 2;
  if (has_vel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->vel_, false, target);
  }

  // required double start_timestamp = 3;
  if (has_start_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->start_timestamp(), target);
  }

  // optional double stop_timestamp = 4;
  if (has_stop_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->stop_timestamp(), target);
  }

  // optional .Vector2 stop_pos = 5;
  if (has_stop_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->stop_pos_, false, target);
  }

  // optional .RobotId robot_id = 6;
  if (has_robot_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->robot_id_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:KickedBall)
  return target;
}

int KickedBall::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:KickedBall)
  int total_size = 0;

  if (has_pos()) {
    // required .Vector2 pos = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pos_);
  }

  if (has_vel()) {
    // required .Vector3 vel = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->vel_);
  }

  if (has_start_timestamp()) {
    // required double start_timestamp = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
int KickedBall::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:KickedBall)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .Vector2 pos = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pos_);

    // required .Vector3 vel = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->vel_);

    // required double start_timestamp = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[3 / 32] & 56u) {
    // optional double stop_timestamp = 4;
    if (has_stop_timestamp()) {
      total_size += 1 + 8;
    }

    // optional .Vector2 stop_pos = 5;
    if (has_stop_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->stop_pos_);
    }

    // optional .RobotId robot_id = 6;
    if (has_robot_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->robot_id_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KickedBall::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:KickedBall)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const KickedBall* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const KickedBall>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:KickedBall)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:KickedBall)
    MergeFrom(*source);
  }
}

void KickedBall::MergeFrom(const KickedBall& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:KickedBall)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      mutable_pos()->::Vector2::MergeFrom(from.pos());
    }
    if (from.has_vel()) {
      mutable_vel()->::Vector3::MergeFrom(from.vel());
    }
    if (from.has_start_timestamp()) {
      set_start_timestamp(from.start_timestamp());
    }
    if (from.has_stop_timestamp()) {
      set_stop_timestamp(from.stop_timestamp());
    }
    if (from.has_stop_pos()) {
      mutable_stop_pos()->::Vector2::MergeFrom(from.stop_pos());
    }
    if (from.has_robot_id()) {
      mutable_robot_id()->::RobotId::MergeFrom(from.robot_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void KickedBall::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:KickedBall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KickedBall::CopyFrom(const KickedBall& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:KickedBall)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KickedBall::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_pos()) {
    if (!this->pos_->IsInitialized()) return false;
  }
  if (has_vel()) {
    if (!this->vel_->IsInitialized()) return false;
  }
  if (has_stop_pos()) {
    if (!this->stop_pos_->IsInitialized()) return false;
  }
  if (has_robot_id()) {
    if (!this->robot_id_->IsInitialized()) return false;
  }
  return true;
}

void KickedBall::Swap(KickedBall* other) {
  if (other == this) return;
  InternalSwap(other);
}
void KickedBall::InternalSwap(KickedBall* other) {
  std::swap(pos_, other->pos_);
  std::swap(vel_, other->vel_);
  std::swap(start_timestamp_, other->start_timestamp_);
  std::swap(stop_timestamp_, other->stop_timestamp_);
  std::swap(stop_pos_, other->stop_pos_);
  std::swap(robot_id_, other->robot_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata KickedBall::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KickedBall_descriptor_;
  metadata.reflection = KickedBall_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// KickedBall

// required .Vector2 pos = 1;
bool KickedBall::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void KickedBall::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
void KickedBall::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
void KickedBall::clear_pos() {
  if (pos_ != NULL) pos_->::Vector2::Clear();
  clear_has_pos();
}
const ::Vector2& KickedBall::pos() const {
  // @@protoc_insertion_point(field_get:KickedBall.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
::Vector2* KickedBall::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::Vector2;
  }
  // @@protoc_insertion_point(field_mutable:KickedBall.pos)
  return pos_;
}
::Vector2* KickedBall::release_pos() {
  // @@protoc_insertion_point(field_release:KickedBall.pos)
  clear_has_pos();
  ::Vector2* temp = pos_;
  pos_ = NULL;
  return temp;
}
void KickedBall::set_allocated_pos(::Vector2* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:KickedBall.pos)
}

// required .Vector3 vel = 2;
bool KickedBall::has_vel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void KickedBall::set_has_vel() {
  _has_bits_[0] |= 0x00000002u;
}
void KickedBall::clear_has_vel() {
  _has_bits_[0] &= ~0x00000002u;
}
void KickedBall::clear_vel() {
  if (vel_ != NULL) vel_->::Vector3::Clear();
  clear_has_vel();
}
const ::Vector3& KickedBall::vel() const {
  // @@protoc_insertion_point(field_get:KickedBall.vel)
  return vel_ != NULL ? *vel_ : *default_instance_->vel_;
}
::Vector3* KickedBall::mutable_vel() {
  set_has_vel();
  if (vel_ == NULL) {
    vel_ = new ::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:KickedBall.vel)
  return vel_;
}
::Vector3* KickedBall::release_vel() {
  // @@protoc_insertion_point(field_release:KickedBall.vel)
  clear_has_vel();
  ::Vector3* temp = vel_;
  vel_ = NULL;
  return temp;
}
void KickedBall::set_allocated_vel(::Vector3* vel) {
  delete vel_;
  vel_ = vel;
  if (vel) {
    set_has_vel();
  } else {
    clear_has_vel();
  }
  // @@protoc_insertion_point(field_set_allocated:KickedBall.vel)
}

// required double start_timestamp = 3;
bool KickedBall::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void KickedBall::set_has_start_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
void KickedBall::clear_has_start_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
void KickedBall::clear_start_timestamp() {
  start_timestamp_ = 0;
  clear_has_start_timestamp();
}
 double KickedBall::start_timestamp() const {
  // @@protoc_insertion_point(field_get:KickedBall.start_timestamp)
  return start_timestamp_;
}
 void KickedBall::set_start_timestamp(double value) {
  set_has_start_timestamp();
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:KickedBall.start_timestamp)
}

// optional double stop_timestamp = 4;
bool KickedBall::has_stop_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void KickedBall::set_has_stop_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
void KickedBall::clear_has_stop_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
void KickedBall::clear_stop_timestamp() {
  stop_timestamp_ = 0;
  clear_has_stop_timestamp();
}
 double KickedBall::stop_timestamp() const {
  // @@protoc_insertion_point(field_get:KickedBall.stop_timestamp)
  return stop_timestamp_;
}
 void KickedBall::set_stop_timestamp(double value) {
  set_has_stop_timestamp();
  stop_timestamp_ = value;
  // @@protoc_insertion_point(field_set:KickedBall.stop_timestamp)
}

// optional .Vector2 stop_pos = 5;
bool KickedBall::has_stop_pos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void KickedBall::set_has_stop_pos() {
  _has_bits_[0] |= 0x00000010u;
}
void KickedBall::clear_has_stop_pos() {
  _has_bits_[0] &= ~0x00000010u;
}
void KickedBall::clear_stop_pos() {
  if (stop_pos_ != NULL) stop_pos_->::Vector2::Clear();
  clear_has_stop_pos();
}
const ::Vector2& KickedBall::stop_pos() const {
  // @@protoc_insertion_point(field_get:KickedBall.stop_pos)
  return stop_pos_ != NULL ? *stop_pos_ : *default_instance_->stop_pos_;
}
::Vector2* KickedBall::mutable_stop_pos() {
  set_has_stop_pos();
  if (stop_pos_ == NULL) {
    stop_pos_ = new ::Vector2;
  }
  // @@protoc_insertion_point(field_mutable:KickedBall.stop_pos)
  return stop_pos_;
}
::Vector2* KickedBall::release_stop_pos() {
  // @@protoc_insertion_point(field_release:KickedBall.stop_pos)
  clear_has_stop_pos();
  ::Vector2* temp = stop_pos_;
  stop_pos_ = NULL;
  return temp;
}
void KickedBall::set_allocated_stop_pos(::Vector2* stop_pos) {
  delete stop_pos_;
  stop_pos_ = stop_pos;
  if (stop_pos) {
    set_has_stop_pos();
  } else {
    clear_has_stop_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:KickedBall.stop_pos)
}

// optional .RobotId robot_id = 6;
bool KickedBall::has_robot_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void KickedBall::set_has_robot_id() {
  _has_bits_[0] |= 0x00000020u;
}
void KickedBall::clear_has_robot_id() {
  _has_bits_[0] &= ~0x00000020u;
}
void KickedBall::clear_robot_id() {
  if (robot_id_ != NULL) robot_id_->::RobotId::Clear();
  clear_has_robot_id();
}
const ::RobotId& KickedBall::robot_id() const {
  // @@protoc_insertion_point(field_get:KickedBall.robot_id)
  return robot_id_ != NULL ? *robot_id_ : *default_instance_->robot_id_;
}
::RobotId* KickedBall::mutable_robot_id() {
  set_has_robot_id();
  if (robot_id_ == NULL) {
    robot_id_ = new ::RobotId;
  }
  // @@protoc_insertion_point(field_mutable:KickedBall.robot_id)
  return robot_id_;
}
::RobotId* KickedBall::release_robot_id() {
  // @@protoc_insertion_point(field_release:KickedBall.robot_id)
  clear_has_robot_id();
  ::RobotId* temp = robot_id_;
  robot_id_ = NULL;
  return temp;
}
void KickedBall::set_allocated_robot_id(::RobotId* robot_id) {
  delete robot_id_;
  robot_id_ = robot_id;
  if (robot_id) {
    set_has_robot_id();
  } else {
    clear_has_robot_id();
  }
  // @@protoc_insertion_point(field_set_allocated:KickedBall.robot_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrackedRobot::kRobotIdFieldNumber;
const int TrackedRobot::kPosFieldNumber;
const int TrackedRobot::kOrientationFieldNumber;
const int TrackedRobot::kVelFieldNumber;
const int TrackedRobot::kVelAngularFieldNumber;
const int TrackedRobot::kVisibilityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrackedRobot::TrackedRobot()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrackedRobot)
}

void TrackedRobot::InitAsDefaultInstance() {
  robot_id_ = const_cast< ::RobotId*>(&::RobotId::default_instance());
  pos_ = const_cast< ::Vector2*>(&::Vector2::default_instance());
  vel_ = const_cast< ::Vector2*>(&::Vector2::default_instance());
}

TrackedRobot::TrackedRobot(const TrackedRobot& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TrackedRobot)
}

void TrackedRobot::SharedCtor() {
  _cached_size_ = 0;
  robot_id_ = NULL;
  pos_ = NULL;
  orientation_ = 0;
  vel_ = NULL;
  vel_angular_ = 0;
  visibility_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrackedRobot::~TrackedRobot() {
  // @@protoc_insertion_point(destructor:TrackedRobot)
  SharedDtor();
}

void TrackedRobot::SharedDtor() {
  if (this != default_instance_) {
    delete robot_id_;
    delete pos_;
    delete vel_;
  }
}

void TrackedRobot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrackedRobot::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrackedRobot_descriptor_;
}

const TrackedRobot& TrackedRobot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto();
  return *default_instance_;
}

TrackedRobot* TrackedRobot::default_instance_ = NULL;

TrackedRobot* TrackedRobot::New(::google::protobuf::Arena* arena) const {
  TrackedRobot* n = new TrackedRobot;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrackedRobot::Clear() {
// @@protoc_insertion_point(message_clear_start:TrackedRobot)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TrackedRobot, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TrackedRobot*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(orientation_, visibility_);
    if (has_robot_id()) {
      if (robot_id_ != NULL) robot_id_->::RobotId::Clear();
    }
    if (has_pos()) {
      if (pos_ != NULL) pos_->::Vector2::Clear();
    }
    if (has_vel()) {
      if (vel_ != NULL) vel_->::Vector2::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrackedRobot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrackedRobot)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .RobotId robot_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pos;
        break;
      }

      // required .Vector2 pos = 2;
      case 2: {
        if (tag == 18) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_orientation;
        break;
      }

      // required float orientation = 3;
      case 3: {
        if (tag == 29) {
         parse_orientation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &orientation_)));
          set_has_orientation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_vel;
        break;
      }

      // optional .Vector2 vel = 4;
      case 4: {
        if (tag == 34) {
         parse_vel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_vel_angular;
        break;
      }

      // optional float vel_angular = 5;
      case 5: {
        if (tag == 45) {
         parse_vel_angular:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vel_angular_)));
          set_has_vel_angular();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_visibility;
        break;
      }

      // optional float visibility = 6;
      case 6: {
        if (tag == 53) {
         parse_visibility:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &visibility_)));
          set_has_visibility();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrackedRobot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrackedRobot)
  return false;
#undef DO_
}

void TrackedRobot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrackedRobot)
  // required .RobotId robot_id = 1;
  if (has_robot_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->robot_id_, output);
  }

  // required .Vector2 pos = 2;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pos_, output);
  }

  // required float orientation = 3;
  if (has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->orientation(), output);
  }

  // optional .Vector2 vel = 4;
  if (has_vel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->vel_, output);
  }

  // optional float vel_angular = 5;
  if (has_vel_angular()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->vel_angular(), output);
  }

  // optional float visibility = 6;
  if (has_visibility()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->visibility(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrackedRobot)
}

::google::protobuf::uint8* TrackedRobot::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrackedRobot)
  // required .RobotId robot_id = 1;
  if (has_robot_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->robot_id_, false, target);
  }

  // required .Vector2 pos = 2;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->pos_, false, target);
  }

  // required float orientation = 3;
  if (has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->orientation(), target);
  }

  // optional .Vector2 vel = 4;
  if (has_vel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->vel_, false, target);
  }

  // optional float vel_angular = 5;
  if (has_vel_angular()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->vel_angular(), target);
  }

  // optional float visibility = 6;
  if (has_visibility()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->visibility(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrackedRobot)
  return target;
}

int TrackedRobot::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TrackedRobot)
  int total_size = 0;

  if (has_robot_id()) {
    // required .RobotId robot_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->robot_id_);
  }

  if (has_pos()) {
    // required .Vector2 pos = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pos_);
  }

  if (has_orientation()) {
    // required float orientation = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
int TrackedRobot::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:TrackedRobot)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .RobotId robot_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->robot_id_);

    // required .Vector2 pos = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pos_);

    // required float orientation = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[3 / 32] & 56u) {
    // optional .Vector2 vel = 4;
    if (has_vel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->vel_);
    }

    // optional float vel_angular = 5;
    if (has_vel_angular()) {
      total_size += 1 + 4;
    }

    // optional float visibility = 6;
    if (has_visibility()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrackedRobot::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrackedRobot)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TrackedRobot* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrackedRobot>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrackedRobot)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrackedRobot)
    MergeFrom(*source);
  }
}

void TrackedRobot::MergeFrom(const TrackedRobot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrackedRobot)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_robot_id()) {
      mutable_robot_id()->::RobotId::MergeFrom(from.robot_id());
    }
    if (from.has_pos()) {
      mutable_pos()->::Vector2::MergeFrom(from.pos());
    }
    if (from.has_orientation()) {
      set_orientation(from.orientation());
    }
    if (from.has_vel()) {
      mutable_vel()->::Vector2::MergeFrom(from.vel());
    }
    if (from.has_vel_angular()) {
      set_vel_angular(from.vel_angular());
    }
    if (from.has_visibility()) {
      set_visibility(from.visibility());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrackedRobot::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrackedRobot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrackedRobot::CopyFrom(const TrackedRobot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrackedRobot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackedRobot::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_robot_id()) {
    if (!this->robot_id_->IsInitialized()) return false;
  }
  if (has_pos()) {
    if (!this->pos_->IsInitialized()) return false;
  }
  if (has_vel()) {
    if (!this->vel_->IsInitialized()) return false;
  }
  return true;
}

void TrackedRobot::Swap(TrackedRobot* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrackedRobot::InternalSwap(TrackedRobot* other) {
  std::swap(robot_id_, other->robot_id_);
  std::swap(pos_, other->pos_);
  std::swap(orientation_, other->orientation_);
  std::swap(vel_, other->vel_);
  std::swap(vel_angular_, other->vel_angular_);
  std::swap(visibility_, other->visibility_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrackedRobot::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrackedRobot_descriptor_;
  metadata.reflection = TrackedRobot_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrackedRobot

// required .RobotId robot_id = 1;
bool TrackedRobot::has_robot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrackedRobot::set_has_robot_id() {
  _has_bits_[0] |= 0x00000001u;
}
void TrackedRobot::clear_has_robot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrackedRobot::clear_robot_id() {
  if (robot_id_ != NULL) robot_id_->::RobotId::Clear();
  clear_has_robot_id();
}
const ::RobotId& TrackedRobot::robot_id() const {
  // @@protoc_insertion_point(field_get:TrackedRobot.robot_id)
  return robot_id_ != NULL ? *robot_id_ : *default_instance_->robot_id_;
}
::RobotId* TrackedRobot::mutable_robot_id() {
  set_has_robot_id();
  if (robot_id_ == NULL) {
    robot_id_ = new ::RobotId;
  }
  // @@protoc_insertion_point(field_mutable:TrackedRobot.robot_id)
  return robot_id_;
}
::RobotId* TrackedRobot::release_robot_id() {
  // @@protoc_insertion_point(field_release:TrackedRobot.robot_id)
  clear_has_robot_id();
  ::RobotId* temp = robot_id_;
  robot_id_ = NULL;
  return temp;
}
void TrackedRobot::set_allocated_robot_id(::RobotId* robot_id) {
  delete robot_id_;
  robot_id_ = robot_id;
  if (robot_id) {
    set_has_robot_id();
  } else {
    clear_has_robot_id();
  }
  // @@protoc_insertion_point(field_set_allocated:TrackedRobot.robot_id)
}

// required .Vector2 pos = 2;
bool TrackedRobot::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrackedRobot::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
void TrackedRobot::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrackedRobot::clear_pos() {
  if (pos_ != NULL) pos_->::Vector2::Clear();
  clear_has_pos();
}
const ::Vector2& TrackedRobot::pos() const {
  // @@protoc_insertion_point(field_get:TrackedRobot.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
::Vector2* TrackedRobot::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::Vector2;
  }
  // @@protoc_insertion_point(field_mutable:TrackedRobot.pos)
  return pos_;
}
::Vector2* TrackedRobot::release_pos() {
  // @@protoc_insertion_point(field_release:TrackedRobot.pos)
  clear_has_pos();
  ::Vector2* temp = pos_;
  pos_ = NULL;
  return temp;
}
void TrackedRobot::set_allocated_pos(::Vector2* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:TrackedRobot.pos)
}

// required float orientation = 3;
bool TrackedRobot::has_orientation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TrackedRobot::set_has_orientation() {
  _has_bits_[0] |= 0x00000004u;
}
void TrackedRobot::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000004u;
}
void TrackedRobot::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
 float TrackedRobot::orientation() const {
  // @@protoc_insertion_point(field_get:TrackedRobot.orientation)
  return orientation_;
}
 void TrackedRobot::set_orientation(float value) {
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:TrackedRobot.orientation)
}

// optional .Vector2 vel = 4;
bool TrackedRobot::has_vel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TrackedRobot::set_has_vel() {
  _has_bits_[0] |= 0x00000008u;
}
void TrackedRobot::clear_has_vel() {
  _has_bits_[0] &= ~0x00000008u;
}
void TrackedRobot::clear_vel() {
  if (vel_ != NULL) vel_->::Vector2::Clear();
  clear_has_vel();
}
const ::Vector2& TrackedRobot::vel() const {
  // @@protoc_insertion_point(field_get:TrackedRobot.vel)
  return vel_ != NULL ? *vel_ : *default_instance_->vel_;
}
::Vector2* TrackedRobot::mutable_vel() {
  set_has_vel();
  if (vel_ == NULL) {
    vel_ = new ::Vector2;
  }
  // @@protoc_insertion_point(field_mutable:TrackedRobot.vel)
  return vel_;
}
::Vector2* TrackedRobot::release_vel() {
  // @@protoc_insertion_point(field_release:TrackedRobot.vel)
  clear_has_vel();
  ::Vector2* temp = vel_;
  vel_ = NULL;
  return temp;
}
void TrackedRobot::set_allocated_vel(::Vector2* vel) {
  delete vel_;
  vel_ = vel;
  if (vel) {
    set_has_vel();
  } else {
    clear_has_vel();
  }
  // @@protoc_insertion_point(field_set_allocated:TrackedRobot.vel)
}

// optional float vel_angular = 5;
bool TrackedRobot::has_vel_angular() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TrackedRobot::set_has_vel_angular() {
  _has_bits_[0] |= 0x00000010u;
}
void TrackedRobot::clear_has_vel_angular() {
  _has_bits_[0] &= ~0x00000010u;
}
void TrackedRobot::clear_vel_angular() {
  vel_angular_ = 0;
  clear_has_vel_angular();
}
 float TrackedRobot::vel_angular() const {
  // @@protoc_insertion_point(field_get:TrackedRobot.vel_angular)
  return vel_angular_;
}
 void TrackedRobot::set_vel_angular(float value) {
  set_has_vel_angular();
  vel_angular_ = value;
  // @@protoc_insertion_point(field_set:TrackedRobot.vel_angular)
}

// optional float visibility = 6;
bool TrackedRobot::has_visibility() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TrackedRobot::set_has_visibility() {
  _has_bits_[0] |= 0x00000020u;
}
void TrackedRobot::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000020u;
}
void TrackedRobot::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
 float TrackedRobot::visibility() const {
  // @@protoc_insertion_point(field_get:TrackedRobot.visibility)
  return visibility_;
}
 void TrackedRobot::set_visibility(float value) {
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:TrackedRobot.visibility)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrackedFrame::kFrameNumberFieldNumber;
const int TrackedFrame::kTimestampFieldNumber;
const int TrackedFrame::kBallsFieldNumber;
const int TrackedFrame::kRobotsFieldNumber;
const int TrackedFrame::kKickedBallFieldNumber;
const int TrackedFrame::kCapabilitiesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrackedFrame::TrackedFrame()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrackedFrame)
}

void TrackedFrame::InitAsDefaultInstance() {
  kicked_ball_ = const_cast< ::KickedBall*>(&::KickedBall::default_instance());
}

TrackedFrame::TrackedFrame(const TrackedFrame& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TrackedFrame)
}

void TrackedFrame::SharedCtor() {
  _cached_size_ = 0;
  frame_number_ = 0u;
  timestamp_ = 0;
  kicked_ball_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrackedFrame::~TrackedFrame() {
  // @@protoc_insertion_point(destructor:TrackedFrame)
  SharedDtor();
}

void TrackedFrame::SharedDtor() {
  if (this != default_instance_) {
    delete kicked_ball_;
  }
}

void TrackedFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrackedFrame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrackedFrame_descriptor_;
}

const TrackedFrame& TrackedFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_5ftracked_2eproto();
  return *default_instance_;
}

TrackedFrame* TrackedFrame::default_instance_ = NULL;

TrackedFrame* TrackedFrame::New(::google::protobuf::Arena* arena) const {
  TrackedFrame* n = new TrackedFrame;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrackedFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:TrackedFrame)
  if (_has_bits_[0 / 32] & 19u) {
    frame_number_ = 0u;
    timestamp_ = 0;
    if (has_kicked_ball()) {
      if (kicked_ball_ != NULL) kicked_ball_->::KickedBall::Clear();
    }
  }
  balls_.Clear();
  robots_.Clear();
  capabilities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrackedFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrackedFrame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 frame_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_number_)));
          set_has_frame_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_timestamp;
        break;
      }

      // required double timestamp = 2;
      case 2: {
        if (tag == 17) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_balls;
        break;
      }

      // repeated .TrackedBall balls = 3;
      case 3: {
        if (tag == 26) {
         parse_balls:
          DO_(input->IncrementRecursionDepth());
         parse_loop_balls:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_balls()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_balls;
        if (input->ExpectTag(34)) goto parse_loop_robots;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .TrackedRobot robots = 4;
      case 4: {
        if (tag == 34) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_robots:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_robots()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_robots;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(42)) goto parse_kicked_ball;
        break;
      }

      // optional .KickedBall kicked_ball = 5;
      case 5: {
        if (tag == 42) {
         parse_kicked_ball:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kicked_ball()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_capabilities;
        break;
      }

      // repeated .Capability capabilities = 6;
      case 6: {
        if (tag == 48) {
         parse_capabilities:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Capability_IsValid(value)) {
            add_capabilities(static_cast< ::Capability >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else if (tag == 50) {
          DO_((::google::protobuf::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 6,
                 ::Capability_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_capabilities())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_capabilities;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrackedFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrackedFrame)
  return false;
#undef DO_
}

void TrackedFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrackedFrame)
  // required uint32 frame_number = 1;
  if (has_frame_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->frame_number(), output);
  }

  // required double timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->timestamp(), output);
  }

  // repeated .TrackedBall balls = 3;
  for (unsigned int i = 0, n = this->balls_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->balls(i), output);
  }

  // repeated .TrackedRobot robots = 4;
  for (unsigned int i = 0, n = this->robots_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->robots(i), output);
  }

  // optional .KickedBall kicked_ball = 5;
  if (has_kicked_ball()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->kicked_ball_, output);
  }

  // repeated .Capability capabilities = 6;
  for (int i = 0; i < this->capabilities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->capabilities(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrackedFrame)
}

::google::protobuf::uint8* TrackedFrame::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrackedFrame)
  // required uint32 frame_number = 1;
  if (has_frame_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->frame_number(), target);
  }

  // required double timestamp = 2;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->timestamp(), target);
  }

  // repeated .TrackedBall balls = 3;
  for (unsigned int i = 0, n = this->balls_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->balls(i), false, target);
  }

  // repeated .TrackedRobot robots = 4;
  for (unsigned int i = 0, n = this->robots_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->robots(i), false, target);
  }

  // optional .KickedBall kicked_ball = 5;
  if (has_kicked_ball()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->kicked_ball_, false, target);
  }

  // repeated .Capability capabilities = 6;
  for (int i = 0; i < this->capabilities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->capabilities(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrackedFrame)
  return target;
}

int TrackedFrame::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TrackedFrame)
  int total_size = 0;

  if (has_frame_number()) {
    // required uint32 frame_number = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->frame_number());
  }

  if (has_timestamp()) {
    // required double timestamp = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
int TrackedFrame::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:TrackedFrame)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 frame_number = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->frame_number());

    // required double timestamp = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .KickedBall kicked_ball = 5;
  if (has_kicked_ball()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kicked_ball_);
  }

  // repeated .TrackedBall balls = 3;
  total_size += 1 * this->balls_size();
  for (int i = 0; i < this->balls_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->balls(i));
  }

  // repeated .TrackedRobot robots = 4;
  total_size += 1 * this->robots_size();
  for (int i = 0; i < this->robots_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->robots(i));
  }

  // repeated .Capability capabilities = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->capabilities_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->capabilities(i));
    }
    total_size += 1 * this->capabilities_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrackedFrame::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrackedFrame)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TrackedFrame* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrackedFrame>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrackedFrame)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrackedFrame)
    MergeFrom(*source);
  }
}

void TrackedFrame::MergeFrom(const TrackedFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrackedFrame)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  balls_.MergeFrom(from.balls_);
  robots_.MergeFrom(from.robots_);
  capabilities_.MergeFrom(from.capabilities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_frame_number()) {
      set_frame_number(from.frame_number());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_kicked_ball()) {
      mutable_kicked_ball()->::KickedBall::MergeFrom(from.kicked_ball());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrackedFrame::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrackedFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrackedFrame::CopyFrom(const TrackedFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrackedFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackedFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->balls())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->robots())) return false;
  if (has_kicked_ball()) {
    if (!this->kicked_ball_->IsInitialized()) return false;
  }
  return true;
}

void TrackedFrame::Swap(TrackedFrame* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrackedFrame::InternalSwap(TrackedFrame* other) {
  std::swap(frame_number_, other->frame_number_);
  std::swap(timestamp_, other->timestamp_);
  balls_.UnsafeArenaSwap(&other->balls_);
  robots_.UnsafeArenaSwap(&other->robots_);
  std::swap(kicked_ball_, other->kicked_ball_);
  capabilities_.UnsafeArenaSwap(&other->capabilities_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrackedFrame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrackedFrame_descriptor_;
  metadata.reflection = TrackedFrame_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrackedFrame

// required uint32 frame_number = 1;
bool TrackedFrame::has_frame_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrackedFrame::set_has_frame_number() {
  _has_bits_[0] |= 0x00000001u;
}
void TrackedFrame::clear_has_frame_number() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrackedFrame::clear_frame_number() {
  frame_number_ = 0u;
  clear_has_frame_number();
}
 ::google::protobuf::uint32 TrackedFrame::frame_number() const {
  // @@protoc_insertion_point(field_get:TrackedFrame.frame_number)
  return frame_number_;
}
 void TrackedFrame::set_frame_number(::google::protobuf::uint32 value) {
  set_has_frame_number();
  frame_number_ = value;
  // @@protoc_insertion_point(field_set:TrackedFrame.frame_number)
}

// required double timestamp = 2;
bool TrackedFrame::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrackedFrame::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void TrackedFrame::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrackedFrame::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
 double TrackedFrame::timestamp() const {
  // @@protoc_insertion_point(field_get:TrackedFrame.timestamp)
  return timestamp_;
}
 void TrackedFrame::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:TrackedFrame.timestamp)
}

// repeated .TrackedBall balls = 3;
int TrackedFrame::balls_size() const {
  return balls_.size();
}
void TrackedFrame::clear_balls() {
  balls_.Clear();
}
const ::TrackedBall& TrackedFrame::balls(int index) const {
  // @@protoc_insertion_point(field_get:TrackedFrame.balls)
  return balls_.Get(index);
}
::TrackedBall* TrackedFrame::mutable_balls(int index) {
  // @@protoc_insertion_point(field_mutable:TrackedFrame.balls)
  return balls_.Mutable(index);
}
::TrackedBall* TrackedFrame::add_balls() {
  // @@protoc_insertion_point(field_add:TrackedFrame.balls)
  return balls_.Add();
}
::google::protobuf::RepeatedPtrField< ::TrackedBall >*
TrackedFrame::mutable_balls() {
  // @@protoc_insertion_point(field_mutable_list:TrackedFrame.balls)
  return &balls_;
}
const ::google::protobuf::RepeatedPtrField< ::TrackedBall >&
TrackedFrame::balls() const {
  // @@protoc_insertion_point(field_list:TrackedFrame.balls)
  return balls_;
}

// repeated .TrackedRobot robots = 4;
int TrackedFrame::robots_size() const {
  return robots_.size();
}
void TrackedFrame::clear_robots() {
  robots_.Clear();
}
const ::TrackedRobot& TrackedFrame::robots(int index) const {
  // @@protoc_insertion_point(field_get:TrackedFrame.robots)
  return robots_.Get(index);
}
::TrackedRobot* TrackedFrame::mutable_robots(int index) {
  // @@protoc_insertion_point(field_mutable:TrackedFrame.robots)
  return robots_.Mutable(index);
}
::TrackedRobot* TrackedFrame::add_robots() {
  // @@protoc_insertion_point(field_add:TrackedFrame.robots)
  return robots_.Add();
}
::google::protobuf::RepeatedPtrField< ::TrackedRobot >*
TrackedFrame::mutable_robots() {
  // @@protoc_insertion_point(field_mutable_list:TrackedFrame.robots)
  return &robots_;
}
const ::google::protobuf::RepeatedPtrField< ::TrackedRobot >&
TrackedFrame::robots() const {
  // @@protoc_insertion_point(field_list:TrackedFrame.robots)
  return robots_;
}

// optional .KickedBall kicked_ball = 5;
bool TrackedFrame::has_kicked_ball() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TrackedFrame::set_has_kicked_ball() {
  _has_bits_[0] |= 0x00000010u;
}
void TrackedFrame::clear_has_kicked_ball() {
  _has_bits_[0] &= ~0x00000010u;
}
void TrackedFrame::clear_kicked_ball() {
  if (kicked_ball_ != NULL) kicked_ball_->::KickedBall::Clear();
  clear_has_kicked_ball();
}
const ::KickedBall& TrackedFrame::kicked_ball() const {
  // @@protoc_insertion_point(field_get:TrackedFrame.kicked_ball)
  return kicked_ball_ != NULL ? *kicked_ball_ : *default_instance_->kicked_ball_;
}
::KickedBall* TrackedFrame::mutable_kicked_ball() {
  set_has_kicked_ball();
  if (kicked_ball_ == NULL) {
    kicked_ball_ = new ::KickedBall;
  }
  // @@protoc_insertion_point(field_mutable:TrackedFrame.kicked_ball)
  return kicked_ball_;
}
::KickedBall* TrackedFrame::release_kicked_ball() {
  // @@protoc_insertion_point(field_release:TrackedFrame.kicked_ball)
  clear_has_kicked_ball();
  ::KickedBall* temp = kicked_ball_;
  kicked_ball_ = NULL;
  return temp;
}
void TrackedFrame::set_allocated_kicked_ball(::KickedBall* kicked_ball) {
  delete kicked_ball_;
  kicked_ball_ = kicked_ball;
  if (kicked_ball) {
    set_has_kicked_ball();
  } else {
    clear_has_kicked_ball();
  }
  // @@protoc_insertion_point(field_set_allocated:TrackedFrame.kicked_ball)
}

// repeated .Capability capabilities = 6;
int TrackedFrame::capabilities_size() const {
  return capabilities_.size();
}
void TrackedFrame::clear_capabilities() {
  capabilities_.Clear();
}
 ::Capability TrackedFrame::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:TrackedFrame.capabilities)
  return static_cast< ::Capability >(capabilities_.Get(index));
}
 void TrackedFrame::set_capabilities(int index, ::Capability value) {
  assert(::Capability_IsValid(value));
  capabilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrackedFrame.capabilities)
}
 void TrackedFrame::add_capabilities(::Capability value) {
  assert(::Capability_IsValid(value));
  capabilities_.Add(value);
  // @@protoc_insertion_point(field_add:TrackedFrame.capabilities)
}
 const ::google::protobuf::RepeatedField<int>&
TrackedFrame::capabilities() const {
  // @@protoc_insertion_point(field_list:TrackedFrame.capabilities)
  return capabilities_;
}
 ::google::protobuf::RepeatedField<int>*
TrackedFrame::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:TrackedFrame.capabilities)
  return &capabilities_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
